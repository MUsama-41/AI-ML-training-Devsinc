# -*- coding: utf-8 -*-
"""python AI/ML training.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o9elyLDHom6DkOPkPQuZ2dqjlsfZVeMt

# Python a dynamic interpreter
which interpretes code line by line and throws type error when particular line is executed and it has type error...in following example, if 'a' given to function is greater than 0 than no error would occured else if a is negative than it would throw error on else
"""

def foo(a):
    if a > 0:
        print('Hi')
    else:
        print("3" + 5)

foo(-1)

"""# Global Variable
although global variable can be accessed in any scope but while changing value for global variable is challengin, we have to use 'global' Keyword while refereing to global variable
"""

x = "awesome"

def myfunc():
  global x
  x = "fantastic"

myfunc()

print("Python is " + x)

"""# Operators along with controle structures
Arithmetic operators
Comparison operators
Logical operators
Bitwise operators
Assignment operators
Specials operators

if/else, for loop and while loop
"""

numbers = [1, 3, 5, 7, 9]

count_equal = 0
count_greater = 0
count_less = 0
count_greater_equal = 0
count_less_equal = 0

threshold = 5

for num in numbers:
    if num == threshold:
        print(num, '==', threshold, 'is True')
        count_equal += 1

    if num != threshold:
        print(num, '!=', threshold, 'is True')

    if num > threshold:
        print(num, '>', threshold, 'is True')
        count_greater += 1

    if num < threshold:
        print(num, '<', threshold, 'is True')
        count_less += 1

    if num >= threshold:
        print(num, '>=', threshold, 'is True')
        count_greater_equal += 1

    if num <= threshold:
        print(num, '<=', threshold, 'is True')
        count_less_equal += 1

i = 0
print("\nResults of counts:")
while i < len(numbers):
    print('Number of elements equal to', threshold, ':', count_equal)
    print('Number of elements greater than', threshold, ':', count_greater)
    print('Number of elements less than', threshold, ':', count_less)
    print('Number of elements greater than or equal to', threshold, ':', count_greater_equal)
    print('Number of elements less than or equal to', threshold, ':', count_less_equal)
    i += 1

"""# Exception Handling"""

try:
    result = 10 / 0
except ZeroDivisionError:
    print("Error: Cannot divide by zero.")

try:
    print("in try")
    result = 10 / 0

except ZeroDivisionError:
    print("Error: Cannot divide by zero.")
else:
    print("The result is:", result)

try:
    print("in try")
    result = 10 / 0
except ZeroDivisionError:
    print("Error: Cannot divide by zero.")
else:
    print("The result is:", result)
finally:
    print("This block always executes.")

"""# Partial functions"""

from functools import partial

def power(base, exponent, mod):
    return (base ** exponent) % mod

power_mod_100 = partial(power, mod=100)

print(power_mod_100(2, 3))
print(power_mod_100(5, 4))

from functools import partial

def power(base, exponent, mod):
    return (base ** exponent) % mod

# Fix both 'exponent' and 'mod'
power_with_exponent_and_mod = partial(power, exponent=3, mod=100)

print(power_with_exponent_and_mod(2))
print(power_with_exponent_and_mod(5))



"""# lambda function
they are unnammed and limited to single expression
"""

# Traditional function
def add(x, y):
    return x + y

add_lambda = lambda x, y: x + y

print(add_lambda(3, 5))

"""# lambda with map
map apply given function to all items in an iterable
"""

numbers = [1, 2, 3, 4, 5]
squared_numbers = list(map(lambda x: x ** 2, numbers))

print(squared_numbers)

numbers = [1, 2, 3, 4, 5]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))

print(even_numbers)

"""# LISTS
spliting string and save into list
"""

# Input the list as string
string = input("Enter elements (Space-Separated): ")

# Split the string and store it to a list
lst = string.split()

# Print the list
print('The list is:', lst)

"""# input string, strip() to remove leading and trailing white spaces

"""

# input size of the list
n = int(input("Enter the size of list : "))
# store integers in a list using map,
# split and strip functions
lst = list(map(int, input("Enter the integer elements:").strip().split()))[:n]

# printing the list
print('The list is:', lst)

"""# appeding tuple and list to list"""

List=[1,2,3,4]
List.append((5,6))
print(List)

List.append(['usama','ASE'])
print(List)

"""# Alternate of append is insert to add data at desired location in list"""

List=[1,2,3,4]

List.insert(3, 12)
List.insert(0, 'Geeks')
print("\nList after performing Insert Operation: ")
print(List)

"""append method cannot add data of different data types at once for this extend mehtod is used"""

List = [1,2,3,4,5]
List.extend([6,7,(9,10),'Usama'])
List

"""# POP vs remove"""

List.remove(5)
List
List.pop(6)
List

"""# Slicing"""

# Creating a List
List = ['G', 'E', 'E', 'K', 'S', 'F',
        'O', 'R', 'G', 'E', 'E', 'K', 'S']
print("Initial List: ")
print(List)

# Print elements from beginning
# to a pre-defined point using Slice
Sliced_List = List[:-6]
print("\nElements sliced till 6th element from last: ")
print(Sliced_List)

# Print elements of a range
# using negative index List slicing
Sliced_List = List[-6:-1]
print("\nElements sliced from index -6 to -1")
print(Sliced_List)

# Printing elements in reverse
# using Slice operation
Sliced_List = List[::-1]
print("\nPrinting List in reverse: ")
print(Sliced_List)

"""# Built in function with LIST"""

from functools import reduce

numbers = [1, 2, 3, 4, 5]

# sum()
print(sum(numbers))

# ord()
print(ord('a'))

# cmp() (custom function for Python 3)
def cmp(a, b):
    return (a > b) - (a < b)
print(cmp([1, 2, 3], [1, 2, 4]))

# max()
print(max(numbers))

# min()
print(min(numbers))

# all()
print(all(numbers))

# any()
print(any(numbers))

# len()
print(len(numbers))

# enumerate()
print(list(enumerate(['a', 'b', 'c'])))

# accumulate()
from itertools import accumulate
print(list(accumulate(numbers)))

# filter()
print(list(filter(lambda x: x > 2, numbers)))

# map()
print(list(map(lambda x: x * 2, numbers)))

# lambda()
add = lambda x, y: x + y
print(add(3, 5))

# reduce()
print(reduce(lambda x, y: x + y, numbers))

"""# Tupple immuteable"""

t = (1, 2, 3, 4)
print(t[1])
print(t[-1])
print(t[1:4])
t1 = (1, 2, 3)
t2 = (4, 5, 6)
print(t1 + t2)
print(t * 3)
print(3 in t)
print(5 in t)
print(len(t))
print(t.count(2))
print(t.index(3))
a, b, c, d = t
print(a, b, c, d)
t = (1, (2, 3), 4)
print(t[1])
print(t[1][0])
t = (1,)
print(t)
t = (1, 2, 3)
l = list(t)
print(l)
l2 = [4, 5, 6]
t2 = tuple(l2)
print(t2)

"""# Sets
sets memory is has base, sequence of storing sets elements cannot be defined
"""

set1 = {1, 2, 3}
set2 = {3, 4, 5}

union_set = set1.union(set2)
print(union_set)  # Output: {1, 2, 3, 4, 5}

intersection_set = set1.intersection(set2)
print(intersection_set)  # Output: {3}

difference_set = set1.difference(set2)
print(difference_set)  # Output: {1, 2}

symmetric_difference_set = set1.symmetric_difference(set2)
print(symmetric_difference_set)  # Output: {1, 2, 4, 5}

set1.add(6)
print(set1)  # Output: {1, 2, 3, 6}

set1.remove(6)
print(set1)  # Output: {1, 2, 3}

set1.discard(2)
print(set1)  # Output: {1, 3}

set1.clear()
print(set1)  # Output: set()

is_subset = {1, 2}.issubset(set2)
print(is_subset)  # Output: False

is_superset = set2.issuperset({3, 4})
print(is_superset)  # Output: True

set1 = {1, 2, 3}
set2 = {3, 4, 5}
set3 = {1, 2}

is_disjoint = set1.isdisjoint(set2)
print(is_disjoint)  # Output: False

is_disjoint = set1.isdisjoint(set3)
print(is_disjoint)  # Output: True

"""# Dictionary"""

my_dict = {'a': 1, 'b': 2, 'c': 3}

# Adding a new key-value pair
my_dict['d'] = 4
print(my_dict)  # Output: {'a': 1, 'b': 2, 'c': 3, 'd': 4}

# Updating an existing key's value
my_dict['a'] = 10
print(my_dict)  # Output: {'a': 10, 'b': 2, 'c': 3, 'd': 4}

# Removing a key-value pair
del my_dict['b']
print(my_dict)  # Output: {'a': 10, 'c': 3, 'd': 4}

# Accessing a value
value = my_dict.get('c')
print(value)  # Output: 3

# Accessing a value with default if key does not exist
value = my_dict.get('e', 'Not Found')
print(value)  # Output: Not Found

# Checking if a key exists
exists = 'd' in my_dict
print(exists)  # Output: True

# Iterating over keys
for key in my_dict:
    print(key, my_dict[key])

# Iterating over values
for value in my_dict.values():
    print(value)

# Iterating over key-value pairs
for key, value in my_dict.items():
    print(key, value)

# Copying the dictionary
dict_copy = my_dict.copy()
print(dict_copy)  # Output: {'a': 10, 'c': 3, 'd': 4}

# Clearing the dictionary
my_dict.clear()
print(my_dict)  # Output: {}

"""#OOP in python"""

class Car:
  def __init__(self,name, milage):
    self._name = name
    self.milage = milage
  # def description(self):
  #   return f"the {self.name} gives milage {self.milage}"

class BMW(Car):
  def __init__(self,speed,name,milage):
    super().__init__(name,milage)
    self.speed = speed

  def description(self):
    return f"{self._name} has average of {self.milage} and max speed of {self.speed}"
obj = BMW(100,"honda","20")
print(obj.description())

class Vehicle:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def description(self):
        return f"{self.make} {self.model}"

class Car(Vehicle):
    def __init__(self, make, model, num_doors):
        super().__init__(make, model)
        self.num_doors = num_doors

    def description(self):
        return f"{self.make} {self.model} with {self.num_doors} doors"

class ElectricCar(Car):
    def __init__(self, make, model, num_doors, battery_capacity):
        super().__init__(make, model, num_doors)
        self.battery_capacity = battery_capacity

    def description(self):
        return f"{self.make} {self.model} with {self.num_doors} doors and {self.battery_capacity}kWh battery"

def print_vehicle_info(vehicle):
    print(vehicle.description())

# Creating instances
vehicle = Vehicle("Toyota", "Camry")
car = Car("Honda", "Civic", 4)
electric_car = ElectricCar("Tesla", "Model S", 4, 100)

# Using the instances
print_vehicle_info(vehicle)
print_vehicle_info(car)
print_vehicle_info(electric_car)

"""# decorators"""

class decorator(object):
  def __init__(self,func):
    self.function = func;
  def __call__(self, a,b):
    result = self.function(a,b)
    return result**2

@decorator
def add(a,b):
  return a+b

add(2,3)